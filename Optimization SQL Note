--3NF
Skinny tables (tables have less columns) = Faster queries
Oracle stores data in a platter and use an armature to read/write data. Oracle stores data in row after row, so when armature read/write rows, it needs to wait platter spin around from row to row, if the row is too large, it takes time for Oracle to move to the next one.
Oracle put Index on PK, not FK.
Put the columns which have high probability to have NULL in value at the end of table. If we have a NULL value at the middle of a row, we still have to go to the end of this row before start to the next row. But if we have the NULL values at the end of row, we can immediately move to next row instead of go to the end of this row.

--Writing SQL
Avoid SELECT * to restrict number of columns
Use WHERE to restrict number of rows
Make sure when use WHERE to compare to a constant value (='A' =120 ='12/12/2020'), the datatypes have to be matched in order to avoid implicit conversion
Use INTERSECT to determine the unique common values between 2 dataset (It is faster than INNER JOIN). We use INNER join to connect 2 or more tables and take specific columns from them
Avoid Sub-queries as we can
We can use IN for multi columns
Using WITH to avoid rerun sub queries if we need to use those many times
Use hint APPEND for inserting, that tells Oracle just append new rows at the end of this table, instead of finding deleted rows and insert new rows there.
The order of tables in FROM clause will affect to runtime of this query. We should put the smallest one at first, then follow by the next smallest. But when we use indexes, the order of those tables in FROM doesn't make sense

--INDEX
Pros:
	Avoid full table scan
	Jump to desired rows
	Speed up JOIN
	Speed up COUNT(): Because just count only Index columns will be slimmer than entire table, so it will be faster.
	Speed up ORDER BY
	Speed up GROUP BY
	Avoid duplication
	Queries will run faster
Cons:
	Waste space: So we should create indexes on neccesary columns instead of all
	Indexes are useful when we access a small portion of database, if we access entire a table, Oracle will ignore the indexes on this table
	If we create an index on 2 columns but we just use 1 of them in WHERE, this index will not be called, so when we create an index on multi columns, we have to consider carefully whether we need to call these columns at once, otherwise the index will waste space
	If the returned data is equal or less then 15% of data in a table, the index will be used. Otherwise, Oracle will ignore the index
	INSERT, DELETE and UPDATE can be slow because not only data is modified, but also the corresponding indexes on this table
	The index can be affected by Hard Drive. Sometimes, the powerful hardware can help the FULL TABLE SCAN is faster than INDEX scan
	
B-tree Index is an upside down of a tree with each leaf is a rowid. We use this kind of index for ID, char, number, date, ...
Bitmap Index is used for columns with a few distinct values (Ex: male/female)
Function-Based Index is an index which is built on a function applied to columns (Ex: CREATE INDEX first_name_idx ON user_data (gender, UPPER(first_name), dob)), Oracle developed this kind of index to avoid when we use a function on an index column, this regular index will not be called.

--B-Tree Index
B-Tree Index is a general purpose index.
We can index one, two or more columns: simple or composite index.
Choosing columns to index depends on the columns that are referenced on WHERE clause.
All ROWID for each value of the column (which we put index) are gathered and placed in the index.
The space for index is less than entire tables' space, so the armature go through it much faster than entire table.
Index is used for subsetting data.
Index is used for data integrity.
Index is used for speed up join.
We don't need to create a simple index on a column which is in a composite index. Because when we access only this column, the composite index can also be used.
The order of columns in a composite index is important.
(Most selective, Least selective). If we use the second column in WHERE clause, it will lead to use INDEX SKIP SCAN.
(Least distinctive, Most distinctive). That means put the highest unique values column first, it will help to reduce number of rows in result set.
Index is used for quality and range conditions (=,>,< BETWEEN) and the not equal conditions, such as: !=, <>, IS NOT won't be considered. In other words, Indexes are used to find data that is there, not for the data that is not there.

CREATE INDEX index_name ON table_name(column_name);
--
SELECT OWNER, TABLE_NAME, TABLESPACE_NAME FROM ALL_TABLES WHERE OWNER='SCOTT' ORDER BY TABLE_NAME;
SELECT TABLE_NAME, TABLESPACE_NAME FROM USER_TABLES ORDER BY TABLE_NAME;
--
SELECT TABLE_NAME, COLUMN_NAME, DATA_TYPE, DATA_LENGTH, NULLABLE FROM ALL_TAB_COLUMNS WHERE OWNER='SCOTT' AND TABLE_NAME='CANDYBAR_FACT' ORDER BY COLUMN_ID;
SELECT TABLE_NAME, COLUMN_NAME, DATA_TYPE, DATA_LENGTH, NULLABLE FROM USER_TAB_COLUMNS WHERE TABLE_NAME='CANDYBAR_FACT' ORDER BY COLUMN_ID;
--
SELECT OWNER, INDEX_NAME, TABLE_OWNER, TABLE_NAME, TABLESPACE_NAME FROM ALL_INDEXES WHERE OWNER='SCOTT' ORDER BY INDEX_NAME, TABLE_OWNER, TABLE_NAME;
SELECT INDEX_NAME, TABLE_OWNER, TABLE_NAME, TABLESPACE_NAME FROM USER_INDEXES ORDER BY INDEX_NAME, TABLE_OWNER;
SELECT TABLE_NAME, INDEX_NAME, COLUMN_NAME FROM ALL_IND_COLUMNS WHERE TABLE_OWNER='SCOTT' ORDER BY TABLE_NAME, INDEX_NAME, COLUMN_POSITION;
SELECT TABLE_NAME, INDEX_NAME, COLUMN_NAME FROM USER_IND_COLUMNS ORDER BY TABLE_NAME, INDEX_NAME, COLUMN_POSITION;
--
DROP INDEX index_name;

After create an index, we have to gather statistics, otherwise Oracle won't consider it. From Oracle 10g, the new indexes will be gathered automatically if the table it is based on has data.
Oracle just considers to use index if the result set is equal or less than 15% entire this table. Otherwise, there is no need for that index, except for JOINS or integrity data.
AUTOTRACE - EXPLAIN PLAN


--Bitmap Index
Distinct column values are much less than total rows in table.
Can index one, two or more columns: simple or composite index.
When we combine 2  or more Bitmap index in a query, the binary numbers AND/OR: 1 & 1 = 1, 1 & 0 = 0, and so on.
Often use in DWH, it's not useful for OLTP which has data change frequently.
Bitmap indexes are useful for performing Ad-hoc queries.
Simple Bitmap Indexes rather than Composite Bitmap Indexes.
Use when degree of cardinality is low.
Don't use on unique columns or column has a large number of distinct values. (Use B-Tree instead)
NULLs included in Bitmap Index (not in B-Tree). When we use WHERE clause with IS NULL condition, Bitmap index could be consider. It contrasts to B-tree index.
Uses less space than corresponding B-Tree index.

CREATE BITMAP INDEX index_name ON table_name(column_name);
DROP INDEX index_name;

AUTOTRACE - EXPLAIN PLAN


--Additional Indexes
Function-Based Indexes
Bitmap Join Indexes
Index-Organized Table













Clips need to be checked:
2. Infrequent Column

4. Function-Based Index
4. Gathering Statistics 
4. Index and Partition interaction
4. Example

5. Create B-tree index
5. Gathering Statistics 
5. Is My Index Being Used?

6. Create Bitmap index
6. Is My Index Being Used?
