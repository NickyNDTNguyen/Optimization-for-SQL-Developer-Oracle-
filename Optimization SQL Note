--3NF
Skinny tables (tables have less columns) = Faster queries
Oracle stores data in a platter and use an armature to read/write data. Oracle stores data in row after row, so when armature read/write rows, it needs to wait platter spin around from row to row, if the row is too large, it takes time for Oracle to move to the next one.
Oracle put Index on PK, not FK.
Put the columns which have high probability to have NULL in value at the end of table. If we have a NULL value at the middle of a row, we still have to go to the end of this row before start to the next row. But if we have the NULL values at the end of row, we can immediately move to next row instead of go to the end of this row.

--Writing SQL
Avoid SELECT * to restrict number of columns
Use WHERE to restrict number of rows
Make sure when use WHERE to compare to a constant value (='A' =120 ='12/12/2020'), the datatypes have to be matched in order to avoid implicit conversion
Use INTERSECT to determine the unique common values between 2 dataset (It is faster than INNER JOIN). We use INNER join to connect 2 or more tables and take specific columns from them
Avoid Sub-queries as we can
We can use IN for multi columns
Using WITH to avoid rerun sub queries if we need to use those many times
Use hint APPEND for inserting, that tells Oracle just append new rows at the end of this table, instead of finding deleted rows and insert new rows there.
The order of tables in FROM clause will affect to runtime of this query. We should put the smallest one at first, then follow by the next smallest. But when we use indexes, the order of those tables in FROM doesn't make sense

--INDEX
Pros:
	Avoid full table scan
	Jump to desired rows
	Speed up JOIN
	Speed up COUNT(): Because just count only Index columns will be slimmer than entire table, so it will be faster.
	Speed up ORDER BY
	Speed up GROUP BY
	Avoid duplication
	Queries will run faster
Cons:
	Waste space: So we should create indexes on neccesary columns instead of all
	Indexes are useful when we access a small portion of database, if we access entire a table, Oracle will ignore the indexes on this table
	When we create an index on one or multi columns, we have to consider carefully whether we need to use these columns, otherwise the index will waste space
	If the returned data is equal or less then 15% of data in a table, the index will be used. Otherwise, Oracle will ignore the index
	INSERT, DELETE and UPDATE can be slow because not only data is modified, but also the corresponding indexes on this table
	The index can be affected by Hard Drive. Sometimes, the powerful hardware can help the FULL TABLE SCAN is faster than INDEX scan
	
B-tree Index is an upside down of a tree with each leaf is a rowid. We use this kind of index for ID, char, number, date, ...
Bitmap Index is used for columns with a few distinct values (Ex: male/female)
Function-Based Index is an index which is built on a function applied to columns (Ex: CREATE INDEX first_name_idx ON user_data (gender, UPPER(first_name), dob)), Oracle developed this kind of index to avoid when we use a function on an index column, this regular index will not be called.
Index-Organized Tables combines table and index into one object and just store based on the primary key.
Bitmap Join Indexes to do the pre-joins two or more tables. This brings us faster joins, faster queries.

Gathering Statistics
Indexes and Partitions

--B-Tree Index
B-Tree Index is a general purpose index.
We can index one, two or more columns: simple or composite index.
Choosing columns to index depends on the columns that are referenced on WHERE clause.
All ROWID for each value of the column (which we put index) are gathered and placed in the index.
The space for index is less than entire tables' space, so the armature go through it much faster than entire table.
Index is used for subsetting data.
Index is used for data integrity.
Index is used for speed up join.
We don't need to create a simple index on a column which is in a composite index. Because when we access only this column, the composite index can also be used.
The order of columns in a composite index is important.
(Most selective, Least selective). If we use the second column in WHERE clause, it will lead to use INDEX SKIP SCAN.
(Least distinctive, Most distinctive). That means put the highest unique values column first, it will help to reduce number of rows in result set.
Index is used for quality and range conditions (=,>,< BETWEEN) and the not equal conditions, such as: !=, <>, IS NOT won't be considered. In other words, Indexes are used to find data that is there, not for the data that is not there.

CREATE INDEX index_name ON table_name(column_name);
--
SELECT OWNER, TABLE_NAME, TABLESPACE_NAME FROM ALL_TABLES WHERE OWNER='SCOTT' ORDER BY TABLE_NAME;
SELECT TABLE_NAME, TABLESPACE_NAME FROM USER_TABLES ORDER BY TABLE_NAME;
--
SELECT TABLE_NAME, COLUMN_NAME, DATA_TYPE, DATA_LENGTH, NULLABLE FROM ALL_TAB_COLUMNS WHERE OWNER='SCOTT' AND TABLE_NAME='CANDYBAR_FACT' ORDER BY COLUMN_ID;
SELECT TABLE_NAME, COLUMN_NAME, DATA_TYPE, DATA_LENGTH, NULLABLE FROM USER_TAB_COLUMNS WHERE TABLE_NAME='CANDYBAR_FACT' ORDER BY COLUMN_ID;
--
SELECT OWNER, INDEX_NAME, TABLE_OWNER, TABLE_NAME, TABLESPACE_NAME FROM ALL_INDEXES WHERE OWNER='SCOTT' ORDER BY INDEX_NAME, TABLE_OWNER, TABLE_NAME;
SELECT INDEX_NAME, TABLE_OWNER, TABLE_NAME, TABLESPACE_NAME FROM USER_INDEXES ORDER BY INDEX_NAME, TABLE_OWNER;
SELECT TABLE_NAME, INDEX_NAME, COLUMN_NAME FROM ALL_IND_COLUMNS WHERE TABLE_OWNER='SCOTT' ORDER BY TABLE_NAME, INDEX_NAME, COLUMN_POSITION;
SELECT TABLE_NAME, INDEX_NAME, COLUMN_NAME FROM USER_IND_COLUMNS ORDER BY TABLE_NAME, INDEX_NAME, COLUMN_POSITION;
--
DROP INDEX index_name;

After create an index, we have to gather statistics, otherwise Oracle won't consider it. From Oracle 10g, the new indexes will be gathered automatically if the table it is based on has data.
Oracle just considers to use index if the result set is equal or less than 15% entire this table. Otherwise, there is no need for that index, except for JOINS or integrity data.
AUTOTRACE - EXPLAIN PLAN


--Bitmap Index
Distinct column values are much less than total rows in table.
Can index one, two or more columns: simple or composite index.
When we combine 2  or more Bitmap index in a query, the binary numbers AND/OR: 1 & 1 = 1, 1 & 0 = 0, and so on.
Often use in DWH, it's not useful for OLTP which has data change frequently.
Bitmap indexes are useful for performing Ad-hoc queries.
Simple Bitmap Indexes rather than Composite Bitmap Indexes.
Use when degree of cardinality is low.
Don't use on unique columns or column has a large number of distinct values. (Use B-Tree instead)
NULLs included in Bitmap Index (not in B-Tree). When we use WHERE clause with IS NULL condition, Bitmap index could be consider. It contrasts to B-tree index.
Uses less space than corresponding B-Tree index.

CREATE BITMAP INDEX index_name ON table_name(column_name);
DROP INDEX index_name;

AUTOTRACE - EXPLAIN PLAN


--Additional Indexes
Function-Based Indexes

Bitmap Join Indexes
Pre-Joins tables -> Reduces SQL runtime.
Usually involves a Fact and Dimension table(s).
One or more additional columns used for subsetting.
Dimension table needs primary key/unique constraint.
ON Clause -> specify dimension table's column(s) in parentheses.
Can include more than one dimension table.
```
CREATE BITMAP INDEX index-name
ON fact-table(B.dimension-column1,...)
FROM fact-tableA,dimension-tableB
WHERE A.key-column=B.key-column

DROP INDEX index-name;
```

Index-Organized Table


--Partition
-Definition
Based on the concept "Smaller Tables -> Faster query execution", Oracle develop Partition feature in the same idea: break apart large tableinto several smaller tables.
Partitioning based on one or more columns (Ex: DATE, etc.)
Handled automatically by Oracle behind the scene.
Each partition can be placed in a separate tablespace.
We even can create partitions in the time of future.
Finally, partitions can also have sub-partitions.

-Partition types
Simple Partitions:
- Range and interval partitioning are useful when organizing similar data, especially date and time data.
	Creates partitions using a range of values.
	Partitions can be defined using one or more columns.
	Can create partitions with non-existent values.
	MAXVALUE keyword will put unhandled values stored in default partition.
	Each partition can be in a separate tablespace.
	WHERE Clause contains partition column, we call that Partition Pruning -> Faster query.
	```
	CREATE TABLE salestable
	  (s_productid  NUMBER,
	   s_saledate   DATE,
	   s_custid     NUMBER,
	   s_totalprice NUMBER)
	PARTITION BY RANGE(s_saledate)
	INTERVAL(NUMTOYMINTERVAL(1,'MONTH')) STORE IN (tbs1,tbs2,tbs3,tbs4)
	 (PARTITION sal05q1 VALUES LESS THAN (TO_DATE('01-APR-2005', 'DD-MON-YYYY')) TABLESPACE tbs1,
	  PARTITION sal05q2 VALUES LESS THAN (TO_DATE('01-JUL-2005', 'DD-MON-YYYY')) TABLESPACE tbs2,
	  PARTITION sal05q3 VALUES LESS THAN (TO_DATE('01-OCT-2005', 'DD-MON-YYYY')) TABLESPACE tbs3,
	  PARTITION sal05q4 VALUES LESS THAN (TO_DATE('01-JAN-2006', 'DD-MON-YYYY')) TABLESPACE tbs4,
	  PARTITION sal06q1 VALUES LESS THAN (TO_DATE('01-APR-2006', 'DD-MON-YYYY')) TABLESPACE tbs1,
	  PARTITION sal06q2 VALUES LESS THAN (TO_DATE('01-JUL-2006', 'DD-MON-YYYY')) TABLESPACE tbs2,
	  PARTITION sal06q3 VALUES LESS THAN (TO_DATE('01-OCT-2006', 'DD-MON-YYYY')) TABLESPACE tbs3,
	  PARTITION sal06q4 VALUES LESS THAN (TO_DATE('01-JAN-2007', 'DD-MON-YYYY')) TABLESPACE tbs4);
	  
	CREATE TABLE sales
	  ( prod_id       NUMBER(6)
	  , cust_id       NUMBER
	  , time_id       DATE
	  , channel_id    CHAR(1)
	  , promo_id      NUMBER(6)
	  , quantity_sold NUMBER(3)
	  , amount_sold   NUMBER(10,2)
	  )
	 PARTITION BY RANGE (time_id)
	 ( PARTITION sales_q1_2006 VALUES LESS THAN (TO_DATE('01-APR-2006','dd-MON-yyyy')) TABLESPACE tsa
	 , PARTITION sales_q2_2006 VALUES LESS THAN (TO_DATE('01-JUL-2006','dd-MON-yyyy')) TABLESPACE tsb
	 , PARTITION sales_q3_2006 VALUES LESS THAN (TO_DATE('01-OCT-2006','dd-MON-yyyy')) TABLESPACE tsc
	 , PARTITION sales_q4_2006 VALUES LESS THAN (TO_DATE('01-JAN-2007','dd-MON-yyyy')) TABLESPACE tsd
	 , PARTITION P_REST 	   VALUES LESS THAN (MAXVALUE)
	 );
	```
	Manage Partitions
	Add new partition
	Split partition
	Drop partition
	Merge partition
	```
	SELECT PARTITION_NAME,
		   HIGH_VALUE
	FROM USER_TAB_PARTITIONS
	WHERE TABLE_NAME='CANDYHIST_PART'
	ORDER BY PARTITION_POSITION;
	```
	Notice: DROP partition will drop data in this partition as well.
	
- List partitioning is useful to explicitly map rows to partitions based on discrete values.
	Create partitions using discrete values of a single column.
	Only allows single column to be the partition key.
	Partition can be defined using one or more values.
	Can create partitions with non-existent values.
	DEFAULT keyword will put unhandled values stored in default partition.
	Each partition can be in a separate tablespace.
	WHERE Clause contains partition column, we call that Partition Pruning -> Faster query.
	```
	CREATE TABLE accounts
	( id             NUMBER
	, account_number NUMBER
	, customer_id    NUMBER
	, branch_id      NUMBER
	, region         VARCHAR(2)
	, status         VARCHAR2(1)
	)
	PARTITION BY LIST (region)
	( PARTITION p_northwest VALUES ('OR', 'WA')
	, PARTITION p_southwest VALUES ('AZ', 'UT', 'NM')
	, PARTITION p_northeast VALUES ('NY', 'VM', 'NJ')
	, PARTITION p_southeast VALUES ('FL', 'GA')
	, PARTITION p_northcentral VALUES ('SD', 'WI')
	, PARTITION p_southcentral VALUES ('OK', 'TX')
	);
	
	CREATE TABLE CANDYHIST_PART(RESPONDENT_IDNUMBER,
								RESPONDENT_NAMEVARCHAR2(100),
								RESPONDENT_ADDRVARCHAR2(100),
								SURVEY_YEARNUMBER,
								...and so on...
								LIKELIHOOD_PURCHASENUMBER,
								NBR_BARS_CONSUMEDNUMBER)
	PARTITION BY LIST (SURVEY_YEAR) (
	PARTITION P_456 VALUES(2004,2005,2006) TABLESPACE TBS_01,
	PARTITION P_789 VALUES(2007,2008,2009) TABLESPACE TBS_02,
	PARTITION P_DEF VALUES(DEFAULT) TABLESPACET BS_03
	);
	```
	
	Manage Partitions
	Add new partition
	Split partition
	Drop partition
	Merge partition
	```
	SELECT TABLE_NAME,
		   PARTITION_NAME,
		   HIGH_VALUE,
		   PARTITION_POSITION
	FROM USER_TAB_PARTITIONS
	WHERE TABLE_NAME='CANDYHIST_PART'
	ORDER BY PARTITION_POSITION;
	
	ALTER TABLE CANDYHIST_PART ADD PARTITION P_2014 VALUES(2014);
	ALTER TABLE CANDYHIST_PART SPLIT PARTITION P_DEF VALUES(2010,2011,2012) INTO (PARTITION P_012, PARTITION P_DEF);
	ALTER TABLE CANDYHIST_PART DROP PARTITION P_DEF;
	ALTER TABLE CANDYHIST_PART MERGE PARTITIONS P_456, P_789 INTO PARTITION P_456789;
	```
	Notice: DROP partition will drop data in this partition as well.
	
- Hash partitioning is useful for randomly distributing data across partitions based on a hashing algorithm, rather than grouping similar data.
	```
	CREATE TABLE sales_hash
	  (s_productid  NUMBER,
	   s_saledate   DATE,
	   s_custid     NUMBER,
	   s_totalprice NUMBER)
	PARTITION BY HASH(s_productid)
	( PARTITION p1 TABLESPACE tbs1
	, PARTITION p2 TABLESPACE tbs2
	, PARTITION p3 TABLESPACE tbs3
	, PARTITION p4 TABLESPACE tbs4
	);
	```
	
Composite Partitions:
Range-List (Ex: SURVEY_DATE/RESPONDENT_GENDER, ...)
List-List (Ex: LIKELIHOOD_PURCHASE/RESPONDENT_GENDER, ...)

-Interaction Between Index and Partition
Indexes within each partition (Local Partitioned Indexes)
Indexes across all partitions (Global Non-Partitioned Indexes), it is similar to create an index on a large table
Indexes with independent partitions (Global Partitioned Indexes)












Clips need to be checked:
2. Infrequent Column

4. Function-Based Index
4. Gathering Statistics 
4. Index and Partition interaction
4. Example

5. Create B-tree index
5. Gathering Statistics 
5. Is My Index Being Used?

6. Create Bitmap index
6. Is My Index Being Used?

7. Function-Based index
7. Index Organized Table

8. Example 
 
9. Create list partition
9. Example list partition
9. Create range partition
9. Example range partition
9. Drop a range partition
10.
11.

